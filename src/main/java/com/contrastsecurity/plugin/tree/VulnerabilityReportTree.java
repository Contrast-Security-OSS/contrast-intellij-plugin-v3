/*******************************************************************************
 * Copyright Â© 2025 Contrast Security, Inc.
 * See https://www.contrastsecurity.com/enduser-terms for more details.
 *******************************************************************************/

package com.contrastsecurity.plugin.tree;

import com.contrastsecurity.plugin.components.ScanComponent;
import com.contrastsecurity.plugin.models.TraceNodeDTO;
import com.contrastsecurity.plugin.utility.TreeUtil;
import com.contrastsecurity.scan.dto.InnerLocation;
import com.contrastsecurity.scan.dto.Vulnerability;
import com.intellij.ui.components.JBPanel;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.ui.treeStructure.Tree;
import java.util.List;
import java.util.Map;
import javax.swing.ScrollPaneConstants;
import javax.swing.tree.DefaultMutableTreeNode;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang3.StringUtils;

@Slf4j
public class VulnerabilityReportTree {
  private final JBPanel<?> panel;
  private final ScanComponent scanComponent;

  public VulnerabilityReportTree(JBPanel<?> panel, ScanComponent scanComponent) {
    this.panel = panel;
    this.scanComponent = scanComponent;
  }

  public void loadScanVulnerabilityReport(
      int totalVulnerabilities, Map<String, List<Vulnerability>> mappedVulnerability) {
    if (totalVulnerabilities > 0 && MapUtils.isNotEmpty(mappedVulnerability)) {
      DefaultMutableTreeNode rootNode = TreeUtil.getRootNode(totalVulnerabilities);
      for (Map.Entry<String, List<Vulnerability>> entry : mappedVulnerability.entrySet()) {
        String key = entry.getKey();
        List<Vulnerability> value = entry.getValue();
        DefaultMutableTreeNode fileNode = TreeUtil.getFileNode(key, value.size());
        addScanVulnerabilityToFileNode(fileNode, value);
        rootNode.add(fileNode);
      }
      Tree tree = TreeUtil.getNormalTree(rootNode);
      addTreeToPanel(tree);
    } else {
      scanComponent.loadDefaultVulnerabilityReport();
    }
  }

  private void addScanVulnerabilityToFileNode(
      DefaultMutableTreeNode fileNode, List<Vulnerability> vulnerabilityList) {
    if (CollectionUtils.isNotEmpty(vulnerabilityList)) {
      for (Vulnerability vulnerability : vulnerabilityList) {
        List<InnerLocation> locations = vulnerability.getLocations();
        for (InnerLocation location : locations) {
          TraceNodeDTO traceNodeDTO = new TraceNodeDTO();
          traceNodeDTO.setTitle(vulnerability.getMessage().getText());
          traceNodeDTO.setSeverity(vulnerability.getSeverity());
          int lineNumber = location.getPhysicalLocation().getRegion().getStartLine();
          if (lineNumber > 0) {
            traceNodeDTO.setLineNumber(String.valueOf(lineNumber));
          } else {
            traceNodeDTO.setLineNumber(StringUtils.EMPTY);
          }
          fileNode.add(new DefaultMutableTreeNode(traceNodeDTO));
        }
      }
    }
  }

  private void addTreeToPanel(Tree tree) {
    JBScrollPane treePane = new JBScrollPane(tree);
    treePane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
    panel.removeAll();
    panel.add(treePane);
    panel.revalidate();
    panel.repaint();
  }
}
